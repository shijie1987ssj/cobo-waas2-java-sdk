/*
 * Cobo Wallet as a Service 2.0
 *
 * Contact: help@cobo.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.cobo.waas2.model;

import java.util.Objects;
import com.cobo.waas2.model.TransactionApprover;
import com.cobo.waas2.model.TransactionBlockInfo;
import com.cobo.waas2.model.TransactionDestination;
import com.cobo.waas2.model.TransactionInitiatorType;
import com.cobo.waas2.model.TransactionRawTxInfo;
import com.cobo.waas2.model.TransactionReplacement;
import com.cobo.waas2.model.TransactionRequestFee;
import com.cobo.waas2.model.TransactionResult;
import com.cobo.waas2.model.TransactionSigner;
import com.cobo.waas2.model.TransactionSource;
import com.cobo.waas2.model.TransactionStatus;
import com.cobo.waas2.model.TransactionSubStatus;
import com.cobo.waas2.model.TransactionTimeline;
import com.cobo.waas2.model.TransactionTokeApproval;
import com.cobo.waas2.model.TransactionType;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.cobo.waas2.JSON;

/**
 * TransactionDetails
 */
@javax.annotation.Generated(
    value = "org.openapitools.codegen.languages.JavaClientCodegen", 
    comments = "Generator version: 7.6.0"
)
public class TransactionDetails {
  public static final String SERIALIZED_NAME_TRANSACTION_ID = "transaction_id";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_ID)
  private UUID transactionId;

  public static final String SERIALIZED_NAME_COBO_ID = "cobo_id";
  @SerializedName(SERIALIZED_NAME_COBO_ID)
  private String coboId;

  public static final String SERIALIZED_NAME_REQUEST_ID = "request_id";
  @SerializedName(SERIALIZED_NAME_REQUEST_ID)
  private String requestId;

  public static final String SERIALIZED_NAME_WALLET_ID = "wallet_id";
  @SerializedName(SERIALIZED_NAME_WALLET_ID)
  private String walletId;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TransactionType type;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private TransactionStatus status;

  public static final String SERIALIZED_NAME_SUB_STATUS = "sub_status";
  @SerializedName(SERIALIZED_NAME_SUB_STATUS)
  private TransactionSubStatus subStatus;

  public static final String SERIALIZED_NAME_FAILED_REASON = "failed_reason";
  @SerializedName(SERIALIZED_NAME_FAILED_REASON)
  private String failedReason;

  public static final String SERIALIZED_NAME_CHAIN_ID = "chain_id";
  @SerializedName(SERIALIZED_NAME_CHAIN_ID)
  private String chainId;

  public static final String SERIALIZED_NAME_TOKEN_ID = "token_id";
  @SerializedName(SERIALIZED_NAME_TOKEN_ID)
  private String tokenId;

  public static final String SERIALIZED_NAME_ASSET_ID = "asset_id";
  @SerializedName(SERIALIZED_NAME_ASSET_ID)
  private String assetId;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private TransactionSource source;

  public static final String SERIALIZED_NAME_DESTINATION = "destination";
  @SerializedName(SERIALIZED_NAME_DESTINATION)
  private TransactionDestination destination;

  public static final String SERIALIZED_NAME_RESULT = "result";
  @SerializedName(SERIALIZED_NAME_RESULT)
  private TransactionResult result;

  public static final String SERIALIZED_NAME_FEE = "fee";
  @SerializedName(SERIALIZED_NAME_FEE)
  private TransactionRequestFee fee;

  public static final String SERIALIZED_NAME_INITIATOR = "initiator";
  @SerializedName(SERIALIZED_NAME_INITIATOR)
  private String initiator;

  public static final String SERIALIZED_NAME_INITIATOR_TYPE = "initiator_type";
  @SerializedName(SERIALIZED_NAME_INITIATOR_TYPE)
  private TransactionInitiatorType initiatorType;

  public static final String SERIALIZED_NAME_CONFIRMED_NUM = "confirmed_num";
  @SerializedName(SERIALIZED_NAME_CONFIRMED_NUM)
  private Integer confirmedNum;

  public static final String SERIALIZED_NAME_CONFIRMING_THRESHOLD = "confirming_threshold";
  @SerializedName(SERIALIZED_NAME_CONFIRMING_THRESHOLD)
  private Integer confirmingThreshold;

  public static final String SERIALIZED_NAME_TRANSACTION_HASH = "transaction_hash";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_HASH)
  private String transactionHash;

  public static final String SERIALIZED_NAME_BLOCK_INFO = "block_info";
  @SerializedName(SERIALIZED_NAME_BLOCK_INFO)
  private TransactionBlockInfo blockInfo;

  public static final String SERIALIZED_NAME_RAW_TX_INFO = "raw_tx_info";
  @SerializedName(SERIALIZED_NAME_RAW_TX_INFO)
  private TransactionRawTxInfo rawTxInfo;

  public static final String SERIALIZED_NAME_REPLACEMENT = "replacement";
  @SerializedName(SERIALIZED_NAME_REPLACEMENT)
  private TransactionReplacement replacement;

  public static final String SERIALIZED_NAME_CATEGORY = "category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  private List<String> category = new ArrayList<>();

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_IS_LOOP = "is_loop";
  @SerializedName(SERIALIZED_NAME_IS_LOOP)
  private Boolean isLoop;

  public static final String SERIALIZED_NAME_CREATED_TIMESTAMP = "created_timestamp";
  @SerializedName(SERIALIZED_NAME_CREATED_TIMESTAMP)
  private Long createdTimestamp;

  public static final String SERIALIZED_NAME_UPDATED_TIMESTAMP = "updated_timestamp";
  @SerializedName(SERIALIZED_NAME_UPDATED_TIMESTAMP)
  private Long updatedTimestamp;

  public static final String SERIALIZED_NAME_APPROVERS = "approvers";
  @SerializedName(SERIALIZED_NAME_APPROVERS)
  private List<TransactionApprover> approvers = new ArrayList<>();

  public static final String SERIALIZED_NAME_SIGNERS = "signers";
  @SerializedName(SERIALIZED_NAME_SIGNERS)
  private List<TransactionSigner> signers = new ArrayList<>();

  public static final String SERIALIZED_NAME_NONCE = "nonce";
  @SerializedName(SERIALIZED_NAME_NONCE)
  private Integer nonce;

  public static final String SERIALIZED_NAME_REPLACED_BY = "replaced_by";
  @SerializedName(SERIALIZED_NAME_REPLACED_BY)
  private String replacedBy;

  public static final String SERIALIZED_NAME_FUELED_BY = "fueled_by";
  @SerializedName(SERIALIZED_NAME_FUELED_BY)
  private String fueledBy;

  public static final String SERIALIZED_NAME_TOKEN_APPROVAL = "token_approval";
  @SerializedName(SERIALIZED_NAME_TOKEN_APPROVAL)
  private TransactionTokeApproval tokenApproval;

  public static final String SERIALIZED_NAME_MESSAGE = "message";
  @SerializedName(SERIALIZED_NAME_MESSAGE)
  private String message;

  public static final String SERIALIZED_NAME_ALGORITHM = "algorithm";
  @SerializedName(SERIALIZED_NAME_ALGORITHM)
  private String algorithm;

  public static final String SERIALIZED_NAME_TIMELINE = "timeline";
  @SerializedName(SERIALIZED_NAME_TIMELINE)
  private List<TransactionTimeline> timeline = new ArrayList<>();

  public TransactionDetails() {
  }

  public TransactionDetails transactionId(UUID transactionId) {
    this.transactionId = transactionId;
    return this;
  }

   /**
   * The transaction ID.
   * @return transactionId
  **/
  @javax.annotation.Nonnull
  public UUID getTransactionId() {
    return transactionId;
  }

  public void setTransactionId(UUID transactionId) {
    this.transactionId = transactionId;
  }


  public TransactionDetails coboId(String coboId) {
    this.coboId = coboId;
    return this;
  }

   /**
   * The Cobo ID, which can be used to track a transaction.
   * @return coboId
  **/
  @javax.annotation.Nullable
  public String getCoboId() {
    return coboId;
  }

  public void setCoboId(String coboId) {
    this.coboId = coboId;
  }


  public TransactionDetails requestId(String requestId) {
    this.requestId = requestId;
    return this;
  }

   /**
   * The request ID that is used to track a transaction request. The request ID is provided by you and must be unique within your organization.
   * @return requestId
  **/
  @javax.annotation.Nullable
  public String getRequestId() {
    return requestId;
  }

  public void setRequestId(String requestId) {
    this.requestId = requestId;
  }


  public TransactionDetails walletId(String walletId) {
    this.walletId = walletId;
    return this;
  }

   /**
   * For deposit transactions, this property represents the wallet ID of the transaction destination. For transactions of other types, this property represents the wallet ID of the transaction source.
   * @return walletId
  **/
  @javax.annotation.Nonnull
  public String getWalletId() {
    return walletId;
  }

  public void setWalletId(String walletId) {
    this.walletId = walletId;
  }


  public TransactionDetails type(TransactionType type) {
    this.type = type;
    return this;
  }

   /**
   * Get type
   * @return type
  **/
  @javax.annotation.Nullable
  public TransactionType getType() {
    return type;
  }

  public void setType(TransactionType type) {
    this.type = type;
  }


  public TransactionDetails status(TransactionStatus status) {
    this.status = status;
    return this;
  }

   /**
   * Get status
   * @return status
  **/
  @javax.annotation.Nonnull
  public TransactionStatus getStatus() {
    return status;
  }

  public void setStatus(TransactionStatus status) {
    this.status = status;
  }


  public TransactionDetails subStatus(TransactionSubStatus subStatus) {
    this.subStatus = subStatus;
    return this;
  }

   /**
   * Get subStatus
   * @return subStatus
  **/
  @javax.annotation.Nullable
  public TransactionSubStatus getSubStatus() {
    return subStatus;
  }

  public void setSubStatus(TransactionSubStatus subStatus) {
    this.subStatus = subStatus;
  }


  public TransactionDetails failedReason(String failedReason) {
    this.failedReason = failedReason;
    return this;
  }

   /**
   * (This property is applicable to approval failures and signature failures only) The reason why the transaction failed.
   * @return failedReason
  **/
  @javax.annotation.Nullable
  public String getFailedReason() {
    return failedReason;
  }

  public void setFailedReason(String failedReason) {
    this.failedReason = failedReason;
  }


  public TransactionDetails chainId(String chainId) {
    this.chainId = chainId;
    return this;
  }

   /**
   * The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](/v2/api-references/wallets/list-enabled-chains).
   * @return chainId
  **/
  @javax.annotation.Nullable
  public String getChainId() {
    return chainId;
  }

  public void setChainId(String chainId) {
    this.chainId = chainId;
  }


  public TransactionDetails tokenId(String tokenId) {
    this.tokenId = tokenId;
    return this;
  }

   /**
   * The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](/v2/api-references/wallets/list-enabled-tokens).
   * @return tokenId
  **/
  @javax.annotation.Nullable
  public String getTokenId() {
    return tokenId;
  }

  public void setTokenId(String tokenId) {
    this.tokenId = tokenId;
  }


  public TransactionDetails assetId(String assetId) {
    this.assetId = assetId;
    return this;
  }

   /**
   * (This concept applies to Exchange Wallets only) The asset ID. An asset ID is the unique identifier of the asset held within your linked exchange account.
   * @return assetId
  **/
  @javax.annotation.Nullable
  public String getAssetId() {
    return assetId;
  }

  public void setAssetId(String assetId) {
    this.assetId = assetId;
  }


  public TransactionDetails source(TransactionSource source) {
    this.source = source;
    return this;
  }

   /**
   * Get source
   * @return source
  **/
  @javax.annotation.Nonnull
  public TransactionSource getSource() {
    return source;
  }

  public void setSource(TransactionSource source) {
    this.source = source;
  }


  public TransactionDetails destination(TransactionDestination destination) {
    this.destination = destination;
    return this;
  }

   /**
   * Get destination
   * @return destination
  **/
  @javax.annotation.Nonnull
  public TransactionDestination getDestination() {
    return destination;
  }

  public void setDestination(TransactionDestination destination) {
    this.destination = destination;
  }


  public TransactionDetails result(TransactionResult result) {
    this.result = result;
    return this;
  }

   /**
   * Get result
   * @return result
  **/
  @javax.annotation.Nullable
  public TransactionResult getResult() {
    return result;
  }

  public void setResult(TransactionResult result) {
    this.result = result;
  }


  public TransactionDetails fee(TransactionRequestFee fee) {
    this.fee = fee;
    return this;
  }

   /**
   * Get fee
   * @return fee
  **/
  @javax.annotation.Nullable
  public TransactionRequestFee getFee() {
    return fee;
  }

  public void setFee(TransactionRequestFee fee) {
    this.fee = fee;
  }


  public TransactionDetails initiator(String initiator) {
    this.initiator = initiator;
    return this;
  }

   /**
   * Transaction initiator
   * @return initiator
  **/
  @javax.annotation.Nullable
  public String getInitiator() {
    return initiator;
  }

  public void setInitiator(String initiator) {
    this.initiator = initiator;
  }


  public TransactionDetails initiatorType(TransactionInitiatorType initiatorType) {
    this.initiatorType = initiatorType;
    return this;
  }

   /**
   * Get initiatorType
   * @return initiatorType
  **/
  @javax.annotation.Nonnull
  public TransactionInitiatorType getInitiatorType() {
    return initiatorType;
  }

  public void setInitiatorType(TransactionInitiatorType initiatorType) {
    this.initiatorType = initiatorType;
  }


  public TransactionDetails confirmedNum(Integer confirmedNum) {
    this.confirmedNum = confirmedNum;
    return this;
  }

   /**
   * Transaction confirmed number
   * @return confirmedNum
  **/
  @javax.annotation.Nullable
  public Integer getConfirmedNum() {
    return confirmedNum;
  }

  public void setConfirmedNum(Integer confirmedNum) {
    this.confirmedNum = confirmedNum;
  }


  public TransactionDetails confirmingThreshold(Integer confirmingThreshold) {
    this.confirmingThreshold = confirmingThreshold;
    return this;
  }

   /**
   * Number of confirmations required for a transaction, such as 15 for ETH chain.
   * @return confirmingThreshold
  **/
  @javax.annotation.Nullable
  public Integer getConfirmingThreshold() {
    return confirmingThreshold;
  }

  public void setConfirmingThreshold(Integer confirmingThreshold) {
    this.confirmingThreshold = confirmingThreshold;
  }


  public TransactionDetails transactionHash(String transactionHash) {
    this.transactionHash = transactionHash;
    return this;
  }

   /**
   * The transaction hash.
   * @return transactionHash
  **/
  @javax.annotation.Nullable
  public String getTransactionHash() {
    return transactionHash;
  }

  public void setTransactionHash(String transactionHash) {
    this.transactionHash = transactionHash;
  }


  public TransactionDetails blockInfo(TransactionBlockInfo blockInfo) {
    this.blockInfo = blockInfo;
    return this;
  }

   /**
   * Get blockInfo
   * @return blockInfo
  **/
  @javax.annotation.Nullable
  public TransactionBlockInfo getBlockInfo() {
    return blockInfo;
  }

  public void setBlockInfo(TransactionBlockInfo blockInfo) {
    this.blockInfo = blockInfo;
  }


  public TransactionDetails rawTxInfo(TransactionRawTxInfo rawTxInfo) {
    this.rawTxInfo = rawTxInfo;
    return this;
  }

   /**
   * Get rawTxInfo
   * @return rawTxInfo
  **/
  @javax.annotation.Nullable
  public TransactionRawTxInfo getRawTxInfo() {
    return rawTxInfo;
  }

  public void setRawTxInfo(TransactionRawTxInfo rawTxInfo) {
    this.rawTxInfo = rawTxInfo;
  }


  public TransactionDetails replacement(TransactionReplacement replacement) {
    this.replacement = replacement;
    return this;
  }

   /**
   * Get replacement
   * @return replacement
  **/
  @javax.annotation.Nullable
  public TransactionReplacement getReplacement() {
    return replacement;
  }

  public void setReplacement(TransactionReplacement replacement) {
    this.replacement = replacement;
  }


  public TransactionDetails category(List<String> category) {
    this.category = category;
    return this;
  }

  public TransactionDetails addCategoryItem(String categoryItem) {
    if (this.category == null) {
      this.category = new ArrayList<>();
    }
    this.category.add(categoryItem);
    return this;
  }

   /**
   * A custom transaction category for you to identify your transfers more easily.
   * @return category
  **/
  @javax.annotation.Nullable
  public List<String> getCategory() {
    return category;
  }

  public void setCategory(List<String> category) {
    this.category = category;
  }


  public TransactionDetails description(String description) {
    this.description = description;
    return this;
  }

   /**
   * The description for your transaction.
   * @return description
  **/
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public TransactionDetails isLoop(Boolean isLoop) {
    this.isLoop = isLoop;
    return this;
  }

   /**
   * Whether the transaction was executed as a [Cobo Loop](https://manuals.cobo.com/en/portal/custodial-wallets/cobo-loop) transfer. - &#x60;true&#x60;: The transaction was executed as a Cobo Loop transfer. - &#x60;false&#x60;: The transaction was not executed as a Cobo Loop transfer. 
   * @return isLoop
  **/
  @javax.annotation.Nullable
  public Boolean getIsLoop() {
    return isLoop;
  }

  public void setIsLoop(Boolean isLoop) {
    this.isLoop = isLoop;
  }


  public TransactionDetails createdTimestamp(Long createdTimestamp) {
    this.createdTimestamp = createdTimestamp;
    return this;
  }

   /**
   * The time when the transaction was created, in Unix timestamp format, measured in milliseconds.
   * @return createdTimestamp
  **/
  @javax.annotation.Nullable
  public Long getCreatedTimestamp() {
    return createdTimestamp;
  }

  public void setCreatedTimestamp(Long createdTimestamp) {
    this.createdTimestamp = createdTimestamp;
  }


  public TransactionDetails updatedTimestamp(Long updatedTimestamp) {
    this.updatedTimestamp = updatedTimestamp;
    return this;
  }

   /**
   * The time when the transaction was updated, in Unix timestamp format, measured in milliseconds.
   * @return updatedTimestamp
  **/
  @javax.annotation.Nullable
  public Long getUpdatedTimestamp() {
    return updatedTimestamp;
  }

  public void setUpdatedTimestamp(Long updatedTimestamp) {
    this.updatedTimestamp = updatedTimestamp;
  }


  public TransactionDetails approvers(List<TransactionApprover> approvers) {
    this.approvers = approvers;
    return this;
  }

  public TransactionDetails addApproversItem(TransactionApprover approversItem) {
    if (this.approvers == null) {
      this.approvers = new ArrayList<>();
    }
    this.approvers.add(approversItem);
    return this;
  }

   /**
   * Get approvers
   * @return approvers
  **/
  @javax.annotation.Nullable
  public List<TransactionApprover> getApprovers() {
    return approvers;
  }

  public void setApprovers(List<TransactionApprover> approvers) {
    this.approvers = approvers;
  }


  public TransactionDetails signers(List<TransactionSigner> signers) {
    this.signers = signers;
    return this;
  }

  public TransactionDetails addSignersItem(TransactionSigner signersItem) {
    if (this.signers == null) {
      this.signers = new ArrayList<>();
    }
    this.signers.add(signersItem);
    return this;
  }

   /**
   * Get signers
   * @return signers
  **/
  @javax.annotation.Nullable
  public List<TransactionSigner> getSigners() {
    return signers;
  }

  public void setSigners(List<TransactionSigner> signers) {
    this.signers = signers;
  }


  public TransactionDetails nonce(Integer nonce) {
    this.nonce = nonce;
    return this;
  }

   /**
   * Transaction nonce
   * @return nonce
  **/
  @javax.annotation.Nullable
  public Integer getNonce() {
    return nonce;
  }

  public void setNonce(Integer nonce) {
    this.nonce = nonce;
  }


  public TransactionDetails replacedBy(String replacedBy) {
    this.replacedBy = replacedBy;
    return this;
  }

   /**
   * Replace by transaction hash
   * @return replacedBy
  **/
  @javax.annotation.Nullable
  public String getReplacedBy() {
    return replacedBy;
  }

  public void setReplacedBy(String replacedBy) {
    this.replacedBy = replacedBy;
  }


  public TransactionDetails fueledBy(String fueledBy) {
    this.fueledBy = fueledBy;
    return this;
  }

   /**
   * Fueled by address
   * @return fueledBy
  **/
  @javax.annotation.Nullable
  public String getFueledBy() {
    return fueledBy;
  }

  public void setFueledBy(String fueledBy) {
    this.fueledBy = fueledBy;
  }


  public TransactionDetails tokenApproval(TransactionTokeApproval tokenApproval) {
    this.tokenApproval = tokenApproval;
    return this;
  }

   /**
   * Get tokenApproval
   * @return tokenApproval
  **/
  @javax.annotation.Nullable
  public TransactionTokeApproval getTokenApproval() {
    return tokenApproval;
  }

  public void setTokenApproval(TransactionTokeApproval tokenApproval) {
    this.tokenApproval = tokenApproval;
  }


  public TransactionDetails message(String message) {
    this.message = message;
    return this;
  }

   /**
   * Transaction raw message
   * @return message
  **/
  @javax.annotation.Nullable
  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }


  public TransactionDetails algorithm(String algorithm) {
    this.algorithm = algorithm;
    return this;
  }

   /**
   * Transaction message signing algorithm
   * @return algorithm
  **/
  @javax.annotation.Nullable
  public String getAlgorithm() {
    return algorithm;
  }

  public void setAlgorithm(String algorithm) {
    this.algorithm = algorithm;
  }


  public TransactionDetails timeline(List<TransactionTimeline> timeline) {
    this.timeline = timeline;
    return this;
  }

  public TransactionDetails addTimelineItem(TransactionTimeline timelineItem) {
    if (this.timeline == null) {
      this.timeline = new ArrayList<>();
    }
    this.timeline.add(timelineItem);
    return this;
  }

   /**
   * Get timeline
   * @return timeline
  **/
  @javax.annotation.Nullable
  public List<TransactionTimeline> getTimeline() {
    return timeline;
  }

  public void setTimeline(List<TransactionTimeline> timeline) {
    this.timeline = timeline;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the TransactionDetails instance itself
   */
  public TransactionDetails putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TransactionDetails transactionDetails = (TransactionDetails) o;
    return Objects.equals(this.transactionId, transactionDetails.transactionId) &&
        Objects.equals(this.coboId, transactionDetails.coboId) &&
        Objects.equals(this.requestId, transactionDetails.requestId) &&
        Objects.equals(this.walletId, transactionDetails.walletId) &&
        Objects.equals(this.type, transactionDetails.type) &&
        Objects.equals(this.status, transactionDetails.status) &&
        Objects.equals(this.subStatus, transactionDetails.subStatus) &&
        Objects.equals(this.failedReason, transactionDetails.failedReason) &&
        Objects.equals(this.chainId, transactionDetails.chainId) &&
        Objects.equals(this.tokenId, transactionDetails.tokenId) &&
        Objects.equals(this.assetId, transactionDetails.assetId) &&
        Objects.equals(this.source, transactionDetails.source) &&
        Objects.equals(this.destination, transactionDetails.destination) &&
        Objects.equals(this.result, transactionDetails.result) &&
        Objects.equals(this.fee, transactionDetails.fee) &&
        Objects.equals(this.initiator, transactionDetails.initiator) &&
        Objects.equals(this.initiatorType, transactionDetails.initiatorType) &&
        Objects.equals(this.confirmedNum, transactionDetails.confirmedNum) &&
        Objects.equals(this.confirmingThreshold, transactionDetails.confirmingThreshold) &&
        Objects.equals(this.transactionHash, transactionDetails.transactionHash) &&
        Objects.equals(this.blockInfo, transactionDetails.blockInfo) &&
        Objects.equals(this.rawTxInfo, transactionDetails.rawTxInfo) &&
        Objects.equals(this.replacement, transactionDetails.replacement) &&
        Objects.equals(this.category, transactionDetails.category) &&
        Objects.equals(this.description, transactionDetails.description) &&
        Objects.equals(this.isLoop, transactionDetails.isLoop) &&
        Objects.equals(this.createdTimestamp, transactionDetails.createdTimestamp) &&
        Objects.equals(this.updatedTimestamp, transactionDetails.updatedTimestamp) &&
        Objects.equals(this.approvers, transactionDetails.approvers) &&
        Objects.equals(this.signers, transactionDetails.signers) &&
        Objects.equals(this.nonce, transactionDetails.nonce) &&
        Objects.equals(this.replacedBy, transactionDetails.replacedBy) &&
        Objects.equals(this.fueledBy, transactionDetails.fueledBy) &&
        Objects.equals(this.tokenApproval, transactionDetails.tokenApproval) &&
        Objects.equals(this.message, transactionDetails.message) &&
        Objects.equals(this.algorithm, transactionDetails.algorithm) &&
        Objects.equals(this.timeline, transactionDetails.timeline)&&
        Objects.equals(this.additionalProperties, transactionDetails.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(transactionId, coboId, requestId, walletId, type, status, subStatus, failedReason, chainId, tokenId, assetId, source, destination, result, fee, initiator, initiatorType, confirmedNum, confirmingThreshold, transactionHash, blockInfo, rawTxInfo, replacement, category, description, isLoop, createdTimestamp, updatedTimestamp, approvers, signers, nonce, replacedBy, fueledBy, tokenApproval, message, algorithm, timeline, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TransactionDetails {\n");
    sb.append("    transactionId: ").append(toIndentedString(transactionId)).append("\n");
    sb.append("    coboId: ").append(toIndentedString(coboId)).append("\n");
    sb.append("    requestId: ").append(toIndentedString(requestId)).append("\n");
    sb.append("    walletId: ").append(toIndentedString(walletId)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    subStatus: ").append(toIndentedString(subStatus)).append("\n");
    sb.append("    failedReason: ").append(toIndentedString(failedReason)).append("\n");
    sb.append("    chainId: ").append(toIndentedString(chainId)).append("\n");
    sb.append("    tokenId: ").append(toIndentedString(tokenId)).append("\n");
    sb.append("    assetId: ").append(toIndentedString(assetId)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    destination: ").append(toIndentedString(destination)).append("\n");
    sb.append("    result: ").append(toIndentedString(result)).append("\n");
    sb.append("    fee: ").append(toIndentedString(fee)).append("\n");
    sb.append("    initiator: ").append(toIndentedString(initiator)).append("\n");
    sb.append("    initiatorType: ").append(toIndentedString(initiatorType)).append("\n");
    sb.append("    confirmedNum: ").append(toIndentedString(confirmedNum)).append("\n");
    sb.append("    confirmingThreshold: ").append(toIndentedString(confirmingThreshold)).append("\n");
    sb.append("    transactionHash: ").append(toIndentedString(transactionHash)).append("\n");
    sb.append("    blockInfo: ").append(toIndentedString(blockInfo)).append("\n");
    sb.append("    rawTxInfo: ").append(toIndentedString(rawTxInfo)).append("\n");
    sb.append("    replacement: ").append(toIndentedString(replacement)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    isLoop: ").append(toIndentedString(isLoop)).append("\n");
    sb.append("    createdTimestamp: ").append(toIndentedString(createdTimestamp)).append("\n");
    sb.append("    updatedTimestamp: ").append(toIndentedString(updatedTimestamp)).append("\n");
    sb.append("    approvers: ").append(toIndentedString(approvers)).append("\n");
    sb.append("    signers: ").append(toIndentedString(signers)).append("\n");
    sb.append("    nonce: ").append(toIndentedString(nonce)).append("\n");
    sb.append("    replacedBy: ").append(toIndentedString(replacedBy)).append("\n");
    sb.append("    fueledBy: ").append(toIndentedString(fueledBy)).append("\n");
    sb.append("    tokenApproval: ").append(toIndentedString(tokenApproval)).append("\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\n");
    sb.append("    algorithm: ").append(toIndentedString(algorithm)).append("\n");
    sb.append("    timeline: ").append(toIndentedString(timeline)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("transaction_id");
    openapiFields.add("cobo_id");
    openapiFields.add("request_id");
    openapiFields.add("wallet_id");
    openapiFields.add("type");
    openapiFields.add("status");
    openapiFields.add("sub_status");
    openapiFields.add("failed_reason");
    openapiFields.add("chain_id");
    openapiFields.add("token_id");
    openapiFields.add("asset_id");
    openapiFields.add("source");
    openapiFields.add("destination");
    openapiFields.add("result");
    openapiFields.add("fee");
    openapiFields.add("initiator");
    openapiFields.add("initiator_type");
    openapiFields.add("confirmed_num");
    openapiFields.add("confirming_threshold");
    openapiFields.add("transaction_hash");
    openapiFields.add("block_info");
    openapiFields.add("raw_tx_info");
    openapiFields.add("replacement");
    openapiFields.add("category");
    openapiFields.add("description");
    openapiFields.add("is_loop");
    openapiFields.add("created_timestamp");
    openapiFields.add("updated_timestamp");
    openapiFields.add("approvers");
    openapiFields.add("signers");
    openapiFields.add("nonce");
    openapiFields.add("replaced_by");
    openapiFields.add("fueled_by");
    openapiFields.add("token_approval");
    openapiFields.add("message");
    openapiFields.add("algorithm");
    openapiFields.add("timeline");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("transaction_id");
    openapiRequiredFields.add("wallet_id");
    openapiRequiredFields.add("status");
    openapiRequiredFields.add("source");
    openapiRequiredFields.add("destination");
    openapiRequiredFields.add("initiator_type");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to TransactionDetails
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TransactionDetails.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TransactionDetails is not found in the empty JSON string", TransactionDetails.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TransactionDetails.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("transaction_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transaction_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transaction_id").toString()));
      }
      if ((jsonObj.get("cobo_id") != null && !jsonObj.get("cobo_id").isJsonNull()) && !jsonObj.get("cobo_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cobo_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cobo_id").toString()));
      }
      if ((jsonObj.get("request_id") != null && !jsonObj.get("request_id").isJsonNull()) && !jsonObj.get("request_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `request_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("request_id").toString()));
      }
      if (!jsonObj.get("wallet_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `wallet_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("wallet_id").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        TransactionType.validateJsonElement(jsonObj.get("type"));
      }
      // validate the required field `status`
      TransactionStatus.validateJsonElement(jsonObj.get("status"));
      // validate the optional field `sub_status`
      if (jsonObj.get("sub_status") != null && !jsonObj.get("sub_status").isJsonNull()) {
        TransactionSubStatus.validateJsonElement(jsonObj.get("sub_status"));
      }
      if ((jsonObj.get("failed_reason") != null && !jsonObj.get("failed_reason").isJsonNull()) && !jsonObj.get("failed_reason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `failed_reason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("failed_reason").toString()));
      }
      if ((jsonObj.get("chain_id") != null && !jsonObj.get("chain_id").isJsonNull()) && !jsonObj.get("chain_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `chain_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("chain_id").toString()));
      }
      if ((jsonObj.get("token_id") != null && !jsonObj.get("token_id").isJsonNull()) && !jsonObj.get("token_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `token_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("token_id").toString()));
      }
      if ((jsonObj.get("asset_id") != null && !jsonObj.get("asset_id").isJsonNull()) && !jsonObj.get("asset_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `asset_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("asset_id").toString()));
      }
      // validate the required field `source`
      TransactionSource.validateJsonElement(jsonObj.get("source"));
      // validate the required field `destination`
      TransactionDestination.validateJsonElement(jsonObj.get("destination"));
      // validate the optional field `result`
      if (jsonObj.get("result") != null && !jsonObj.get("result").isJsonNull()) {
        TransactionResult.validateJsonElement(jsonObj.get("result"));
      }
      // validate the optional field `fee`
      if (jsonObj.get("fee") != null && !jsonObj.get("fee").isJsonNull()) {
        TransactionRequestFee.validateJsonElement(jsonObj.get("fee"));
      }
      if ((jsonObj.get("initiator") != null && !jsonObj.get("initiator").isJsonNull()) && !jsonObj.get("initiator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `initiator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("initiator").toString()));
      }
      // validate the required field `initiator_type`
      TransactionInitiatorType.validateJsonElement(jsonObj.get("initiator_type"));
      if ((jsonObj.get("transaction_hash") != null && !jsonObj.get("transaction_hash").isJsonNull()) && !jsonObj.get("transaction_hash").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transaction_hash` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transaction_hash").toString()));
      }
      // validate the optional field `block_info`
      if (jsonObj.get("block_info") != null && !jsonObj.get("block_info").isJsonNull()) {
        TransactionBlockInfo.validateJsonElement(jsonObj.get("block_info"));
      }
      // validate the optional field `raw_tx_info`
      if (jsonObj.get("raw_tx_info") != null && !jsonObj.get("raw_tx_info").isJsonNull()) {
        TransactionRawTxInfo.validateJsonElement(jsonObj.get("raw_tx_info"));
      }
      // validate the optional field `replacement`
      if (jsonObj.get("replacement") != null && !jsonObj.get("replacement").isJsonNull()) {
        TransactionReplacement.validateJsonElement(jsonObj.get("replacement"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("category") != null && !jsonObj.get("category").isJsonNull() && !jsonObj.get("category").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `category` to be an array in the JSON string but got `%s`", jsonObj.get("category").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if (jsonObj.get("approvers") != null && !jsonObj.get("approvers").isJsonNull()) {
        JsonArray jsonArrayapprovers = jsonObj.getAsJsonArray("approvers");
        if (jsonArrayapprovers != null) {
          // ensure the json data is an array
          if (!jsonObj.get("approvers").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `approvers` to be an array in the JSON string but got `%s`", jsonObj.get("approvers").toString()));
          }

          // validate the optional field `approvers` (array)
          for (int i = 0; i < jsonArrayapprovers.size(); i++) {
            TransactionApprover.validateJsonElement(jsonArrayapprovers.get(i));
          };
        }
      }
      if (jsonObj.get("signers") != null && !jsonObj.get("signers").isJsonNull()) {
        JsonArray jsonArraysigners = jsonObj.getAsJsonArray("signers");
        if (jsonArraysigners != null) {
          // ensure the json data is an array
          if (!jsonObj.get("signers").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `signers` to be an array in the JSON string but got `%s`", jsonObj.get("signers").toString()));
          }

          // validate the optional field `signers` (array)
          for (int i = 0; i < jsonArraysigners.size(); i++) {
            TransactionSigner.validateJsonElement(jsonArraysigners.get(i));
          };
        }
      }
      if ((jsonObj.get("replaced_by") != null && !jsonObj.get("replaced_by").isJsonNull()) && !jsonObj.get("replaced_by").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `replaced_by` to be a primitive type in the JSON string but got `%s`", jsonObj.get("replaced_by").toString()));
      }
      if ((jsonObj.get("fueled_by") != null && !jsonObj.get("fueled_by").isJsonNull()) && !jsonObj.get("fueled_by").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fueled_by` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fueled_by").toString()));
      }
      // validate the optional field `token_approval`
      if (jsonObj.get("token_approval") != null && !jsonObj.get("token_approval").isJsonNull()) {
        TransactionTokeApproval.validateJsonElement(jsonObj.get("token_approval"));
      }
      if ((jsonObj.get("message") != null && !jsonObj.get("message").isJsonNull()) && !jsonObj.get("message").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `message` to be a primitive type in the JSON string but got `%s`", jsonObj.get("message").toString()));
      }
      if ((jsonObj.get("algorithm") != null && !jsonObj.get("algorithm").isJsonNull()) && !jsonObj.get("algorithm").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `algorithm` to be a primitive type in the JSON string but got `%s`", jsonObj.get("algorithm").toString()));
      }
      if (jsonObj.get("timeline") != null && !jsonObj.get("timeline").isJsonNull()) {
        JsonArray jsonArraytimeline = jsonObj.getAsJsonArray("timeline");
        if (jsonArraytimeline != null) {
          // ensure the json data is an array
          if (!jsonObj.get("timeline").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `timeline` to be an array in the JSON string but got `%s`", jsonObj.get("timeline").toString()));
          }

          // validate the optional field `timeline` (array)
          for (int i = 0; i < jsonArraytimeline.size(); i++) {
            TransactionTimeline.validateJsonElement(jsonArraytimeline.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TransactionDetails.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TransactionDetails' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TransactionDetails> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TransactionDetails.class));

       return (TypeAdapter<T>) new TypeAdapter<TransactionDetails>() {
           @Override
           public void write(JsonWriter out, TransactionDetails value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additional properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   JsonElement jsonElement = gson.toJsonTree(entry.getValue());
                   if (jsonElement.isJsonArray()) {
                     obj.add(entry.getKey(), jsonElement.getAsJsonArray());
                   } else {
                     obj.add(entry.getKey(), jsonElement.getAsJsonObject());
                   }
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public TransactionDetails read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             JsonObject jsonObj = jsonElement.getAsJsonObject();
             // store additional fields in the deserialized instance
             TransactionDetails instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TransactionDetails given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TransactionDetails
  * @throws IOException if the JSON string is invalid with respect to TransactionDetails
  */
  public static TransactionDetails fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TransactionDetails.class);
  }

 /**
  * Convert an instance of TransactionDetails to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

